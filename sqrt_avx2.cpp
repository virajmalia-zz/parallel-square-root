/*******************************************************************
  This file has been automatically generated by ispc
  DO NOT EDIT THIS FILE DIRECTLY
 *******************************************************************/

/* Provide Declarations */
#include <stdarg.h>
#include <setjmp.h>
#include <limits.h>
#include <stdlib.h>
#ifdef _MSC_VER
  #define NOMINMAX
  #include <windows.h>
#endif // _MSC_VER
#include <stdlib.h>
#include <stdint.h>
/* get a declaration for alloca */
#ifdef _MSC_VER
  #include <malloc.h>
  #define alloca _alloca
#else
  #include <alloca.h>
#endif

#undef ISPC_FAST_MATH
#include "generic_defs.h"

/* Basic Library Function Declarations */
extern "C" {
int puts(unsigned char *);
unsigned int putchar(unsigned int);
int fflush(void *);
int printf(const unsigned char *, ...);
uint8_t *memcpy(uint8_t *, uint8_t *, uint64_t );
uint8_t *memset(uint8_t *, uint8_t, uint64_t );
void memset_pattern16(void *, const void *, uint64_t );
}

#ifndef __GNUC__  /* Can only support "linkonce" vars with GCC */
#define __attribute__(X)
#endif

#if defined(__GNUC__) && defined(__APPLE_CC__)
#define __EXTERNAL_WEAK__ __attribute__((weak_import))
#elif defined(__GNUC__)
#define __EXTERNAL_WEAK__ __attribute__((weak))
#else
#define __EXTERNAL_WEAK__
#endif

#if defined(__GNUC__) && defined(__APPLE_CC__)
#define __ATTRIBUTE_WEAK__
#elif defined(__GNUC__)
#define __ATTRIBUTE_WEAK__ __attribute__((weak))
#else
#define __ATTRIBUTE_WEAK__
#endif

#if defined(__GNUC__)
#define __HIDDEN__ __attribute__((visibility("hidden")))
#endif

#if (defined(__GNUC__) || defined(__clang__)) && !defined(__INTEL_COMPILER)
#define LLVM_NAN(NanStr)   __builtin_nan(NanStr)   /* Double */
#define LLVM_NANF(NanStr)  __builtin_nanf(NanStr)  /* Float */
#define LLVM_NANS(NanStr)  __builtin_nans(NanStr)  /* Double */
#define LLVM_NANSF(NanStr) __builtin_nansf(NanStr) /* Float */
#define LLVM_INF           __builtin_inf()         /* Double */
#define LLVM_INFF          __builtin_inff()        /* Float */
//#define LLVM_PREFETCH(addr,rw,locality) __builtin_prefetch(addr,rw,locality)
//#define __ATTRIBUTE_CTOR__ __attribute__((constructor))
//#define __ATTRIBUTE_DTOR__ __attribute__((destructor))
#elif defined(_MSC_VER) || defined(__INTEL_COMPILER)
#include <limits>
#define LLVM_NAN(NanStr)   std::numeric_limits<double>::quiet_NaN()
#define LLVM_NANF(NanStr)  std::numeric_limits<float>::quiet_NaN()
#define LLVM_NANS(NanStr)  std::numeric_limits<double>::signaling_NaN()
#define LLVM_NANSF(NanStr) std::numeric_limits<float>::signaling_NaN()
#define LLVM_INF           std::numeric_limits<double>::infinity()
#define LLVM_INFF          std::numeric_limits<float>::infinity()
//#define LLVM_PREFETCH(addr,rw,locality)            /* PREFETCH */
//#define __ATTRIBUTE_CTOR__
//#define __ATTRIBUTE_DTOR__
#else
#error "Not MSVC, clang, or g++?"
#endif

#if (defined(__GNUC__) || defined(__clang__))
#define LLVM_ASM(X) __asm(X)
#endif

#if defined(__clang__) || defined(__INTEL_COMPILER) || (__GNUC__ < 4) /* Old GCCs, or compilers not GCC */ 
#define __builtin_stack_save() 0   /* not implemented */
#define __builtin_stack_restore(X) /* noop */
#endif

#define CODE_FOR_MAIN() /* Any target-specific code for main()*/

#ifndef __cplusplus
typedef unsigned char bool;
#endif


/* Support for floating point constants */
typedef uint64_t ConstantDoubleTy;
typedef uint32_t ConstantFloatTy;
typedef struct { unsigned long long f1; unsigned short f2; unsigned short pad[3]; } ConstantFP80Ty;
typedef struct { uint64_t f1, f2; } ConstantFP128Ty;


/* Global Declarations */


/* Helper union for bitcasts */
typedef union {
  unsigned int Int32;
  unsigned long long Int64;
  float Float;
  double Double;
} llvmBitCastUnion;

/* This is special class, designed for operations with long int.*/                       
namespace {                                                                                
template <int num_bits>                                                                    
struct iN {                                                                                
  int num[num_bits / (sizeof (int) * 8)];                                                  
                                                                                           
  iN () {}                                                                                 
                                                                                           
  iN (const char *val) {                                                                   
    if (val == NULL)                                                                       
      return;                                                                              
    int length = num_bits / (sizeof (int) * 8);                                            
    int val_len = 0;                                                                       
    for (val_len = 0; val[val_len]; (val_len)++);                                          
    for (int i = 0; (i < val_len && i < num_bits); i++)                                    
      num[i / (sizeof (int) * 8)] = (num[i / (sizeof (int) * 8)] << 1) | (val[i] - '0');   
  }                                                                                        
                                                                                           
  ~iN () {}                                                                                
                                                                                           
  iN operator >> (const iN rhs) {                                                          
    iN res;                                                                                
    int length = num_bits / (sizeof (int) * 8);                                            
    int cells_shift = rhs.num[0] / (sizeof(int) * 8);                                      
    int small_shift = rhs.num[0] % (sizeof(int) * 8);                                      
    for (int i = 0; i < (length - cells_shift); i++)                                       
      res.num[i] = this->num[cells_shift + i];                                             
    for (int i = 0; i < length - 1; i++) {                                                 
      res.num[i] = this->num[i] >> small_shift;                                            
      res.num[i]  = ((this->num[i + 1] << ((sizeof(int) * 8) - small_shift))) | res.num[i];
    }                                                                                      
    res.num[length - 1] = res.num[length - 1] >> small_shift;                              
    return res;                                                                            
  }                                                                                        
                                                                                           
  iN operator & (iN rhs) {                                                                 
    iN res;                                                                                
    int length = num_bits / (sizeof (int) * 8);                                            
    for (int i = 0; i < length; i++)                                                       
      res.num[i] = (this->num[i]) & (rhs.num[i]);                                          
    return res;                                                                            
  }                                                                                        
                                                                                           
  operator uint32_t() { return this->num[0]; }                                             
                                                                                           
  template <class T>                                                                       
  friend iN<num_bits> __cast_bits(iN<num_bits> to, T from) {                               
    for (int i = 0; i <4; i++)                                         
      to.num[i] = ((int*)(&from))[i];                                                      
    return to;                                                                             
  }                                                                                        
                                                                                           
  template <class T>                                                                       
  friend T __cast_bits(T to, iN<num_bits> from) {                                          
    for (int i = 0; i <4; i++)                                         
      ((int*)(&to))[i] = from.num[i];                                                      
    return to;                                                                             
  }                                                                                        
                                                                                           
  template <int ALIGN, class T>                                                            
  friend void __store(T *p, iN<num_bits> val) {                                            
    for (int i = 0; i <4; i++)                                         
      ((int*)p)[i] = val.num[i];                                                           
  }                                                                                        
};                                                                                         
};

/* Structure and array forward declarations */
struct l_unnamed_0;
namespace {
};

/* Structure and array contents */
struct l_unnamed_0 {
  static l_unnamed_0 init(float *v0, uint32_t v1, float *v2, uint32_t v3, __vec4_i1 v4) {
    l_unnamed_0 ret;
    ret.field0 = v0;
    ret.field1 = v1;
    ret.field2 = v2;
    ret.field3 = v3;
    ret.field4 = v4;
    return ret;
  }
  float *field0;
  uint32_t field1;
  float *field2;
  uint32_t field3;
  __vec4_i1 field4;
};

namespace {
};


/* Function Declarations */
extern "C" {
uint8_t *ISPCAlloc(uint8_t **, uint64_t , uint32_t );
void ISPCLaunch(uint8_t **, uint8_t *, uint8_t *, uint32_t , uint32_t , uint32_t );
void ISPCSync(uint8_t *);
void launchedSquareRoot___un_3C_unf_3E_uniun_3C_unf_3E_uni(l_unnamed_0 *, uint32_t , uint32_t , uint32_t , uint32_t , uint32_t , uint32_t , uint32_t , uint32_t , uint32_t , uint32_t );
void squareRoot___un_3C_unf_3E_uniun_3C_unf_3E_(float *n_, uint32_t N_, float *result_, __vec4_i1 __mask_);
void squareRoot(float *n_, uint32_t N_, float *result_);
}



/* Function Bodies */
template <typename A, typename B> static inline int llvm_fcmp_ord(A X, B Y) { return X == X && Y == Y; }
template <typename A, typename B> static inline int llvm_fcmp_uno(A X, B Y) { return X != X || Y != Y; }
template <typename A, typename B> static inline int llvm_fcmp_ueq(A X, B Y) { return X == Y || llvm_fcmp_uno(X, Y); }
template <typename A, typename B> static inline int llvm_fcmp_une(A X, B Y) { return X != Y; }
template <typename A, typename B> static inline int llvm_fcmp_ult(A X, B Y) { return X <  Y || llvm_fcmp_uno(X, Y); }
template <typename A, typename B> static inline int llvm_fcmp_ugt(A X, B Y) { return X >  Y || llvm_fcmp_uno(X, Y); }
template <typename A, typename B> static inline int llvm_fcmp_ule(A X, B Y) { return X <= Y || llvm_fcmp_uno(X, Y); }
template <typename A, typename B> static inline int llvm_fcmp_uge(A X, B Y) { return X >= Y || llvm_fcmp_uno(X, Y); }
template <typename A, typename B> static inline int llvm_fcmp_oeq(A X, B Y) { return X == Y ; }
template <typename A, typename B> static inline int llvm_fcmp_one(A X, B Y) { return X != Y && llvm_fcmp_ord(X, Y); }
template <typename A, typename B> static inline int llvm_fcmp_olt(A X, B Y) { return X <  Y ; }
template <typename A, typename B> static inline int llvm_fcmp_ogt(A X, B Y) { return X >  Y ; }
template <typename A, typename B> static inline int llvm_fcmp_ole(A X, B Y) { return X <= Y ; }
template <typename A, typename B> static inline int llvm_fcmp_oge(A X, B Y) { return X >= Y ; }
template <typename A> A *Memset(A *ptr, int count, size_t len) { return (A *)memset(ptr, count, len); }

static const int32_t __attribute__ ((aligned(16))) VectorConstant0[] = { 0u, 1u, 2u, 3u,  };

void launchedSquareRoot___un_3C_unf_3E_uniun_3C_unf_3E_uni(l_unnamed_0 *tmp__1_, uint32_t tmp__2_, uint32_t tmp__3_, uint32_t tmp__4_, uint32_t tmp__5_, uint32_t tmp__6_, uint32_t tmp__7_, uint32_t tmp__8_, uint32_t tmp__9_, uint32_t tmp__10_, uint32_t tmp__11_) {
  float *n2_;
  float *result6_;
  uint32_t width8_;
  uint32_t mul_taskIndex_load_width_load_;
  uint32_t add_start_load_width_load9_;
  uint32_t sub_add_start_load_width_load9__;
  uint32_t aligned_end_;
  uint8_t *n_load_ptr2int_2void_;
  uint8_t *result_load_ptr2int_2void_;
  uint32_t counter_2e_1229_;
  uint32_t counter_2e_1229___PHI;
  uint64_t tmp__12_;
  uint8_t *ptr_;
  __vec4_f ptr_masked_load166_;
  __vec4_i1 greater_sub_x_load_y_load_e_load_broadcast221_;
  bool internal_mask_26_function_mask41_any223_;
  uint32_t counter_2e_1_2e_lcssa_;
  uint32_t counter_2e_1_2e_lcssa___PHI;
  __vec4_i1 oldMask_26_test226_;
  __vec4_i1 oldMask_26_test226___PHI;
  __vec4_f y_2e_0225_;
  __vec4_f y_2e_0225___PHI;
  __vec4_f x_2e_0224_;
  __vec4_f x_2e_0224___PHI;
  __vec4_f v1_2e_i_;
  __vec4_f ptr176_masked_load_;
  __vec4_f v1_2e_i206_;
  __vec4_i1 oldMask_26_test_and_mask_;
  bool internal_mask_26_function_mask41_any_;
  __vec4_f x_2e_0_2e_lcssa_;
  __vec4_f x_2e_0_2e_lcssa___PHI;
  uint32_t new_counter_;
  __vec4_i32 counter_2e_1_2e_lcssa_smear_;
  __vec4_i32 sub_add_start_load_width_load9__smear_;
  __vec4_i1 cmp79_;
  uint64_t tmp__13_;
  uint8_t *ptr170_;
  __vec4_f ptr170_masked_load_;
  __vec4_i1 oldMask_26_test103215_and_mask_;
  bool internal_mask_26_function_mask107_any216_;
  __vec4_i1 oldMask_26_test103219_;
  __vec4_i1 oldMask_26_test103219___PHI;
  __vec4_f y91_2e_0218_;
  __vec4_f y91_2e_0218___PHI;
  __vec4_f x84_2e_0217_;
  __vec4_f x84_2e_0217___PHI;
  __vec4_f v1_2e_i204_;
  __vec4_f ptr191_masked_load_;
  __vec4_f v1_2e_i202_;
  __vec4_i1 oldMask_26_test103_and_mask_;
  bool internal_mask_26_function_mask107_any_;
  __vec4_f x84_2e_0_2e_lcssa_;
  __vec4_f x84_2e_0_2e_lcssa___PHI;

  n2_ = *((&tmp__1_->field0));
  result6_ = *((&tmp__1_->field2));
  width8_ = *((&tmp__1_->field3));
  mul_taskIndex_load_width_load_ = ((uint32_t )(((uint32_t )width8_) * ((uint32_t )tmp__4_)));
  add_start_load_width_load9_ = ((uint32_t )(((uint32_t )width8_) + ((uint32_t )4294967295u)));
  sub_add_start_load_width_load9__ = ((uint32_t )(((uint32_t )add_start_load_width_load9_) + ((uint32_t )mul_taskIndex_load_width_load_)));
  aligned_end_ = ((uint32_t )(((uint32_t )sub_add_start_load_width_load9__) - ((uint32_t )(((int32_t )(((int32_t )add_start_load_width_load9_) % ((int32_t )4u)))))));
  if ((((int32_t )mul_taskIndex_load_width_load_) < ((int32_t )aligned_end_))) {
    goto foreach_full_body_2e_lr_2e_ph_label;
  } else {
    counter_2e_1_2e_lcssa___PHI = mul_taskIndex_load_width_load_;   /* for PHI node */
    goto partial_inner_all_outer_label;
  }

foreach_full_body_2e_lr_2e_ph_label: {
  n_load_ptr2int_2void_ = ((uint8_t *)n2_);
  result_load_ptr2int_2void_ = ((uint8_t *)result6_);
  counter_2e_1229___PHI = mul_taskIndex_load_width_load_;   /* for PHI node */
  goto foreach_full_body_label;

}
  do {     /* Syntactic loop 'foreach_full_body' to make GCC happy */
foreach_full_body_label: {
  counter_2e_1229_ = counter_2e_1229___PHI;
  tmp__12_ = ((int64_t )(int32_t )(counter_2e_1229_ << 2u));
  ptr_ = (&n_load_ptr2int_2void_[((int64_t )tmp__12_)]);
  ptr_masked_load166_ = __load<4>((((__vec4_f (*))ptr_)));
  greater_sub_x_load_y_load_e_load_broadcast221_ = __greater_than_float((__add(ptr_masked_load166_, __smear_float<__vec4_f>(-0x1p+0))), __smear_float<__vec4_f>(0x1.a36e2ep-14));
  internal_mask_26_function_mask41_any223_ = (( /*tail*/ __any(greater_sub_x_load_y_load_e_load_broadcast221_))&1);
  if (internal_mask_26_function_mask41_any223_) {
    oldMask_26_test226___PHI = greater_sub_x_load_y_load_e_load_broadcast221_;   /* for PHI node */
    y_2e_0225___PHI = __smear_float<__vec4_f>(0x1p+0);   /* for PHI node */
    x_2e_0224___PHI = ptr_masked_load166_;   /* for PHI node */
    goto for_loop_label;
  } else {
    x_2e_0_2e_lcssa___PHI = ptr_masked_load166_;   /* for PHI node */
    goto for_exit_label;
  }

}
  do {     /* Syntactic loop 'for_loop' to make GCC happy */
for_loop_label: {
  oldMask_26_test226_ = oldMask_26_test226___PHI;
  y_2e_0225_ = y_2e_0225___PHI;
  x_2e_0224_ = x_2e_0224___PHI;
  v1_2e_i_ = __select(oldMask_26_test226_, (__div((__add(x_2e_0224_, y_2e_0225_)), __smear_float<__vec4_f>(0x1p+1))), x_2e_0224_);
  ptr176_masked_load_ =  /*tail*/ __masked_load_float(ptr_, oldMask_26_test226_);
  v1_2e_i206_ = __select(oldMask_26_test226_, (__div(ptr176_masked_load_, v1_2e_i_)), y_2e_0225_);
  oldMask_26_test_and_mask_ = __greater_than_float_and_mask((__sub(v1_2e_i_, v1_2e_i206_)), __smear_float<__vec4_f>(0x1.a36e2ep-14), oldMask_26_test226_);
  internal_mask_26_function_mask41_any_ = (( /*tail*/ __any(oldMask_26_test_and_mask_))&1);
  if (internal_mask_26_function_mask41_any_) {
    oldMask_26_test226___PHI = oldMask_26_test_and_mask_;   /* for PHI node */
    y_2e_0225___PHI = v1_2e_i206_;   /* for PHI node */
    x_2e_0224___PHI = v1_2e_i_;   /* for PHI node */
    goto for_loop_label;
  } else {
    x_2e_0_2e_lcssa___PHI = v1_2e_i_;   /* for PHI node */
    goto for_exit_label;
  }

}
  } while (1); /* end of syntactic loop 'for_loop' */
for_exit_label: {
  x_2e_0_2e_lcssa_ = x_2e_0_2e_lcssa___PHI;
  __store<4>((((__vec4_f (*))((&result_load_ptr2int_2void_[((int64_t )tmp__12_)])))), x_2e_0_2e_lcssa_);
  new_counter_ = ((uint32_t )(((uint32_t )counter_2e_1229_) + ((uint32_t )4u)));
  if ((((int32_t )new_counter_) < ((int32_t )aligned_end_))) {
    counter_2e_1229___PHI = new_counter_;   /* for PHI node */
    goto foreach_full_body_label;
  } else {
    counter_2e_1_2e_lcssa___PHI = new_counter_;   /* for PHI node */
    goto partial_inner_all_outer_label;
  }

}
  } while (1); /* end of syntactic loop 'foreach_full_body' */
foreach_reset_label: {
  return;
}
partial_inner_all_outer_label: {
  counter_2e_1_2e_lcssa_ = counter_2e_1_2e_lcssa___PHI;
  if ((((int32_t )counter_2e_1_2e_lcssa_) < ((int32_t )sub_add_start_load_width_load9__))) {
    goto partial_inner_only_label;
  } else {
    goto foreach_reset_label;
  }

}
partial_inner_only_label: {
  counter_2e_1_2e_lcssa_smear_ = __smear_i32<__vec4_i32>(counter_2e_1_2e_lcssa_);
  sub_add_start_load_width_load9__smear_ = __smear_i32<__vec4_i32>(sub_add_start_load_width_load9__);
  cmp79_ = __signed_less_than_i32((__add(counter_2e_1_2e_lcssa_smear_, __load<16>((const __vec4_i32  *)(VectorConstant0)))), sub_add_start_load_width_load9__smear_);
  tmp__13_ = ((int64_t )(int32_t )(counter_2e_1_2e_lcssa_ << 2u));
  ptr170_ = (&(((uint8_t *)n2_))[((int64_t )tmp__13_)]);
  ptr170_masked_load_ =  /*tail*/ __masked_load_float(ptr170_, cmp79_);
  oldMask_26_test103215_and_mask_ = __greater_than_float_and_mask((__add(ptr170_masked_load_, __smear_float<__vec4_f>(-0x1p+0))), __smear_float<__vec4_f>(0x1.a36e2ep-14), cmp79_);
  internal_mask_26_function_mask107_any216_ = (( /*tail*/ __any(oldMask_26_test103215_and_mask_))&1);
  if (internal_mask_26_function_mask107_any216_) {
    oldMask_26_test103219___PHI = oldMask_26_test103215_and_mask_;   /* for PHI node */
    y91_2e_0218___PHI = __smear_float<__vec4_f>(0x1p+0);   /* for PHI node */
    x84_2e_0217___PHI = ptr170_masked_load_;   /* for PHI node */
    goto for_loop94_label;
  } else {
    x84_2e_0_2e_lcssa___PHI = ptr170_masked_load_;   /* for PHI node */
    goto for_exit95_label;
  }

}
  do {     /* Syntactic loop 'for_loop94' to make GCC happy */
for_loop94_label: {
  oldMask_26_test103219_ = oldMask_26_test103219___PHI;
  y91_2e_0218_ = y91_2e_0218___PHI;
  x84_2e_0217_ = x84_2e_0217___PHI;
  v1_2e_i204_ = __select(oldMask_26_test103219_, (__div((__add(x84_2e_0217_, y91_2e_0218_)), __smear_float<__vec4_f>(0x1p+1))), x84_2e_0217_);
  ptr191_masked_load_ =  /*tail*/ __masked_load_float(ptr170_, oldMask_26_test103219_);
  v1_2e_i202_ = __select(oldMask_26_test103219_, (__div(ptr191_masked_load_, v1_2e_i204_)), y91_2e_0218_);
  oldMask_26_test103_and_mask_ = __greater_than_float_and_mask((__sub(v1_2e_i204_, v1_2e_i202_)), __smear_float<__vec4_f>(0x1.a36e2ep-14), oldMask_26_test103219_);
  internal_mask_26_function_mask107_any_ = (( /*tail*/ __any(oldMask_26_test103_and_mask_))&1);
  if (internal_mask_26_function_mask107_any_) {
    oldMask_26_test103219___PHI = oldMask_26_test103_and_mask_;   /* for PHI node */
    y91_2e_0218___PHI = v1_2e_i202_;   /* for PHI node */
    x84_2e_0217___PHI = v1_2e_i204_;   /* for PHI node */
    goto for_loop94_label;
  } else {
    x84_2e_0_2e_lcssa___PHI = v1_2e_i204_;   /* for PHI node */
    goto for_exit95_label;
  }

}
  } while (1); /* end of syntactic loop 'for_loop94' */
for_exit95_label: {
  x84_2e_0_2e_lcssa_ = x84_2e_0_2e_lcssa___PHI;
  __masked_store_float((((__vec4_f (*))((&(((uint8_t *)result6_))[((int64_t )tmp__13_)])))), x84_2e_0_2e_lcssa_, cmp79_);
  goto foreach_reset_label;

}
}



void squareRoot___un_3C_unf_3E_uniun_3C_unf_3E_(float *n_, uint32_t N_, float *result_, __vec4_i1 __mask_) {
  uint8_t *launch_group_handle_;    /* Address-exposed local */
  uint8_t *args_ptr_;
  uint8_t *launch_group_handle_load_;

  *(&launch_group_handle_) = ((uint8_t *)/*NULL*/0);
  args_ptr_ = ISPCAlloc((&launch_group_handle_), 48ull, 16u);
  *(((float **)args_ptr_)) = n_;
  *(((uint32_t *)((&args_ptr_[((int64_t )8ull)])))) = N_;
  *(((float **)((&args_ptr_[((int64_t )16ull)])))) = result_;
  *(((uint32_t *)((&args_ptr_[((int64_t )24ull)])))) = 3000000u;
  __store<16>((((__vec4_i1 (*))((&args_ptr_[((int64_t )32ull)])))), __mask_);
  ISPCLaunch((&launch_group_handle_), ((uint8_t *)launchedSquareRoot___un_3C_unf_3E_uniun_3C_unf_3E_uni), args_ptr_, 5u, 1u, 1u);
  launch_group_handle_load_ = *(&launch_group_handle_);
  if ((launch_group_handle_load_ == ((uint8_t *)/*NULL*/0))) {
    goto post_sync13_label;
  } else {
    goto call_sync_label;
  }

call_sync_label: {
  ISPCSync(launch_group_handle_load_);
  *(&launch_group_handle_) = ((uint8_t *)/*NULL*/0);
  goto post_sync13_label;

}
post_sync13_label: {
  return;
}
}



void squareRoot(float *n_, uint32_t N_, float *result_) {
  uint8_t *launch_group_handle_;    /* Address-exposed local */
  uint8_t *args_ptr_;
  uint8_t *launch_group_handle_load_;

  *(&launch_group_handle_) = ((uint8_t *)/*NULL*/0);
  args_ptr_ = ISPCAlloc((&launch_group_handle_), 48ull, 16u);
  *(((float **)args_ptr_)) = n_;
  *(((uint32_t *)((&args_ptr_[((int64_t )8ull)])))) = N_;
  *(((float **)((&args_ptr_[((int64_t )16ull)])))) = result_;
  *(((uint32_t *)((&args_ptr_[((int64_t )24ull)])))) = 3000000u;
  __store<16>((((__vec4_i1 (*))((&args_ptr_[((int64_t )32ull)])))), __smear_i1<__vec4_i1>(1));
  ISPCLaunch((&launch_group_handle_), ((uint8_t *)launchedSquareRoot___un_3C_unf_3E_uniun_3C_unf_3E_uni), args_ptr_, 5u, 1u, 1u);
  launch_group_handle_load_ = *(&launch_group_handle_);
  if ((launch_group_handle_load_ == ((uint8_t *)/*NULL*/0))) {
    goto post_sync13_label;
  } else {
    goto call_sync_label;
  }

call_sync_label: {
  ISPCSync(launch_group_handle_load_);
  *(&launch_group_handle_) = ((uint8_t *)/*NULL*/0);
  goto post_sync13_label;

}
post_sync13_label: {
  return;
}
}

